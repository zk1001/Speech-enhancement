function code = genFunctionCell(net,name,filepath,sampleColumn)

% Copyright 2012-2015 The MathWorks, Inc.

isDynamic = (net.numInputDelays > 0) && (net.numLayerDelays > 0);
useTransposedData = (~sampleColumn && ~isDynamic);
code = [...
    functionInterface(net,name) ...
    functionSummary(name) ...
    {'%'} ...
    nnet.codegen.commentText(functionHelp(net,filepath,name,useTransposedData)) ...
    {''} ...
    {'%#ok<*RPMT0>'} ...
    {''} ...
    {'% ===== NEURAL NETWORK CONSTANTS ====='} ...
    {''} ...
    nnet.codegen.constantBlock(net) ...
    {''} ...
    {'% ===== SIMULATION ========'} ...
    {''} ...
    simulationBlock(net,useTransposedData) ...
    {'end'} ...
    {''} ...
    {'% ===== MODULE FUNCTIONS ========'} ...
    {''} ...
    nnet.codegen.allModuleFunctions(net) ...
    ];
end

function code = functionInterface(net,name)
code = {['function ' functionCall(net,name,true)]};
end

function code = functionCall(net,name,includeIgnored)
import nnet.codegen.*;
isDynamic = (net.numInputDelays + net.numLayerDelays) > 0;
inputs = {'X','Xi','Ai'};
if (net.numInputDelays == 0), inputs{2} = '~'; end
if (net.numLayerDelays == 0), inputs{3} = '~'; end
if isDynamic
    outputs = {'Y','Xf','Af'};
elseif includeIgnored
    outputs = {'Y','Xf','Af'};
else
    outputs = {'Y'};
end
inputs = commaList(inputs);
outputs = commaList(outputs);
code = ['[' outputs '] = ' name '(' inputs ')'];
end

function code = functionSummary(name)
code = {['%' upper(name) ' neural network simulation function.']};
end

function code = functionHelp(net,filepath,name,useTransposedData)
import nnet.codegen.*;
code = combineTextBlocks({...
    sourceSummary ...
    syntaxHelp(net,name,useTransposedData)  ...
    });
end

function code = sourceSummary
code = {['Generated by Neural Network Toolbox function genFunction, ' datestr(datevec(now)) '.']};
end

function code = syntaxHelp(net,name,useTransposedData)
import nnet.codegen.*;
isDynamic = (net.numInputDelays + net.numLayerDelays) > 0;
code = {};
output2layer = find(net.outputConnect);
numInputDelays = num2str(net.numInputDelays);
numLayerDelays = num2str(net.numLayerDelays);
code{end+1} = [functionCall(net,name,false) ' takes these arguments:'];
code{end+1} = '';
code{end+1} = ['  X = ',num2str(net.numInputs),'xTS cell, ' num2str(net.numInputs) ' inputs over TS timesteps'];
if (useTransposedData)
    for i=1:net.numInputs
        code{end+1} = ['  Each X{',num2str(i),',ts} = Qx',num2str(net.inputs{i}.size),' matrix, input #' num2str(i) ' at timestep ts.'];
    end
else
    for i=1:net.numInputs
        code{end+1} = ['  Each X{',num2str(i),',ts} = ',num2str(net.inputs{i}.size),'xQ matrix, input #' num2str(i) ' at timestep ts.'];
    end
end
code{end+1} = '';
if isDynamic
    code{end+1} = ['  Xi = ',num2str(net.numInputs),'x' numInputDelays ' cell ' num2str(net.numInputs) ', initial ' numInputDelays ' input delay states.'];
    for i=1:net.numInputs
        code{end+1} = ['  Each Xi{',num2str(i),',ts} = ',num2str(net.inputs{i}.size),'xQ matrix, initial states for input #' num2str(i) '.'];
    end
    code{end+1} = '';
    code{end+1} = ['  Ai = ',num2str(net.numLayers),'x' numLayerDelays ' cell ' num2str(net.numLayers) ', initial ' numInputDelays ' layer delay states.'];
    for i=1:net.numLayers
        code{end+1} = ['  Each Ai{',num2str(i),',ts} = ',num2str(net.layers{i}.size),'xQ matrix, initial states for layer #' num2str(i) '.'];
    end
    code{end+1} = '';
end
code{end+1} = 'and returns:';
code{end+1} = ['  Y = ',num2str(net.numOutputs),'xTS cell of ' num2str(net.numInputs) ' outputs over TS timesteps.'];
if (useTransposedData)
    for i=1:net.numOutputs
        ii = output2layer(i);
        code{end+1} = ['  Each Y{' num2str(i) ',ts} = Qx',num2str(net.outputs{ii}.size),' matrix, output #' num2str(i) ' at timestep ts.'];
    end
else
    for i=1:net.numOutputs
        ii = output2layer(i);
        code{end+1} = ['  Each Y{' num2str(i) ',ts} = ',num2str(net.outputs{ii}.size),'xQ matrix, output #' num2str(i) ' at timestep ts.'];
    end
end
code{end+1} = '';
if isDynamic
    code{end+1} = ['  Xf = ',num2str(net.numInputs),'x' numInputDelays ' cell ' num2str(net.numInputs) ', final ' numInputDelays ' input delay states.'];
    for i=1:net.numInputs
        code{end+1} = ['  Each Xf{',num2str(i),',ts} = ',num2str(net.inputs{i}.size),'xQ matrix, final states for input #' num2str(i) '.'];
    end
    code{end+1} = '';
    code{end+1} = ['  Af = ',num2str(net.numLayers),'x' numLayerDelays ' cell ' num2str(net.numLayers) ', final ' numLayerDelays ' layer delay states.'];
    for i=1:net.numLayers
        code{end+1} = ['  Each Af{',num2str(i),'ts} = ',num2str(net.layers{i}.size),'xQ matrix, final states for layer #' num2str(i) '.'];
    end
    code{end+1} = '';
end
code{end+1} = 'where Q is number of samples (or series) and TS is the number of timesteps.';
end

function code = simulationBlock(net,useTransposedData)
import nnet.codegen.*;
import nnet.nn.*;
inputStateBlocks = {};
for i=1:net.numInputs
    if isInputDelayed(net,i)
        inputStateBlocks{end+1} = simulateInputState(net,i);
    end
end
defaults = {};
if (net.numInputDelays > 0)
    defaults = [ ...
        defaults ...
        {'if isempty(Xi)'} ...
        {['  Xi=cell(' num2str(net.numInputs) ',' num2str(net.numInputDelays) ');']} ...
        ];
    for i=1:net.numInputs
        defaults{end+1} = ['  Xi(' num2str(i) ',:) = {zeros(' num2str(net.inputs{i}.size) ',Q)};'];
    end
    defaults{end+1} = 'end';
end
if (net.numLayerDelays > 0)
    defaults = [...
        defaults ...
        {'if isempty(Ai)'} ...
        {['  Ai=cell(' num2str(net.numLayers) ',' num2str(net.numLayerDelays) ');']} ...
        ];
    for i=1:net.numLayers
        defaults{end+1} = ['  Ai(' num2str(i) ',:) = {zeros(' num2str(net.layers{i}.size) ',Q)};'];
    end
    defaults{end+1} = 'end';
else
    defaults = {};
end
if (net.numInputDelays + net.numLayerDelays) > 0
    tsdCode = {'  % Rotating delay state position'};
    if (net.numInputDelays > 0)
        tsdCode{end+1} = ['  xdts = mod(ts+' num2str(net.numInputDelays-1) ',' num2str(net.numInputDelays+1) ')+1;'];
    end
    if (net.numLayerDelays > 0)
        tsdCode{end+1} = ['  adts = mod(ts+' num2str(net.numLayerDelays-1) ',' num2str(net.numLayerDelays+1) ')+1;'];
    end
    if ~isempty(tsdCode), tsdCode{end+1} = ''; end
    finaltsCode = {};
    if (net.numInputDelays > 0)
        finaltsCode = [finaltsCode {
            ['finalxts = TS+(1: ' num2str(net.numInputDelays) ');'] ...
            ['xits = finalxts(finalxts<=' num2str(net.numInputDelays) ');'] ...
            ['xts = finalxts(finalxts>' num2str(net.numInputDelays) ')-' num2str(net.numInputDelays) ';'] ...
            }];
    end
    if (net.numLayerDelays > 0)
        finaltsCode = [finaltsCode {
            ['finalats = TS+(1: ' num2str(net.numLayerDelays) ');'] ...
            ['ats = mod(finalats-1,' num2str(net.numLayerDelays+1) ')+1;'] ...
            }];
    end
else
    tsdCode = {};
    finaltsCode = {};
end
if needQ(net)
    if (useTransposedData)
        qBlock = { ...
            'if ~isempty(X)' ...
            '    Q = size(X{1},1); % samples/series' ...
            };
    else
        qBlock = { ...
            'if ~isempty(X)' ...
            '  Q = size(X{1},2); % samples/series' ...
            };
    end
    if (net.numInputDelays > 0)
        qBlock = [qBlock { ...
            'elseif ~isempty(Xi)' ...
            '  Q = size(Xi{1},2);' ...
            }];
    end
    if (net.numLayerDelays > 0)
        qBlock = [qBlock { ...
            'elseif ~isempty(Ai)' ...
            '  Q = size(Ai{1},2);' ...
            }];
    end
    qBlock = [qBlock { ...
        'else' ...
        '  Q = 0;' ...
        'end' ...
        }];
else
    qBlock = {};
end
if (net.numInputDelays > 0)
    xiBlock = {'if (nargin < 2), error(''Initial input states Xi argument needed.''); end'};
else
    xiBlock = {};
end
if (net.numLayerDelays > 0)
    aiBlock = {'if (nargin < 3), error(''Initial input states Ai argument needed.''); end'};
else
    aiBlock = {};
end
code = [ ...
    {'% Format Input Arguments'} ...
    {'isCellX = iscell(X);'} ...
    {'if ~isCellX, X = {X}; end;'} ...
    xiBlock ...
    aiBlock ...
    {''} ...
    {'% Dimensions'} ...
    {'TS = size(X,2); % timesteps'} ...
    qBlock ...
    defaults ...
    {''} ...
    combineTextBlocks([
    inputStateBlocks ...
    {encloseText('% Layer Delay States',allocateLayerStates(net))} ...
    {encloseText('% Allocate Outputs',allocateOutputs(net))} ...
    ]) ...
    {''} ...
    {'% Time loop'} ...
    {'for ts=1:TS'} ...
    {''} ...
    indentText([ ...
    tsdCode ...
    timeBlock(net,useTransposedData) ...
    ]) ...
    {'end'} ...
    {''} ...
    {'% Final Delay States'} ...
    finaltsCode ...
    finalInputStates(net) ...
    finalLayerStates(net) ...
    {''} ...
    {'% Format Output Arguments'} ...
    {'if ~isCellX, Y = cell2mat(Y); end'} ...
    ];
end

function flag = needQ(net)
flag = false;
for i=1:net.numLayers
    if net.biasConnect(i)
        flag = true; return;
    end
    if all([net.inputConnect(i,:) net.layerConnect(i,:)] == false)
        flag = true; return;
    end
end
end

function code = timeBlock(net,useTransposedData)
import nnet.codegen.*;
inputBlocks = cell(1,net.numInputs);
for i=1:net.numInputs
    inputBlocks{i} = simulateInput(net,i,useTransposedData);
end
layerBlocks = cell(1,net.numLayers);
layerOrder = nn.layer_order(net);
for i=1:net.numLayers
    layerBlocks{i} = simulateLayer(net,layerOrder(i));
end
outputBlocks = cell(1,net.numOutputs);
for i=1:net.numOutputs
    outputBlocks{i} = simulateOutput(net,i,useTransposedData);
end
code = combineTextBlocks([inputBlocks layerBlocks outputBlocks]);
end

function code = simulateInputState(net,i)
import nnet.codegen.*;
code = {};
ND = num2str(net.numInputDelays);
numFcns = numel(net.inputs{i}.processFcns);
if (numFcns > 0) && (net.numInputDelays > 0)
    lastVar = ['Xi{' num2str(i) ',ts}'];
    nextVar = 'temp';
    processedVar = ['Xd' num2str(i) '{ts}'];
    for j=1:numFcns
        if (j==numFcns), nextVar = processedVar; end
        module = net.inputs{i}.processFcns{j};
        if ~isempty(getStructFieldsFromMFile(module,'apply','settings'))
            settings = inputSettingName(i,j);
        else
            settings = '[]';
        end
        code{end+1} = [nextVar ' = ' module '_apply(' lastVar ',' settings ');'];
        lastVar = 'temp';
    end
    code = [...
        {['% Input ',num2str(i) ' Delay States']} ...
        {['Xd' num2str(i) ' = cell(1,' num2str(net.numInputDelays+1) ');']} ...
        {['for ts=1:' ND]} ...
        indentText(code) ...
        {'end'} ...
        ];
else
    code = {...
        ['% Input ',num2str(i) ' Delay States'] ...
        ['Xd' num2str(i) ' = Xi(' num2str(i) ',:);'] ...
        };
end
end

function code = allocateLayerStates(net)
code = {};
if (net.numLayerDelays > 0)
    for i=1:net.numLayers
        code{end+1} = ['Ad' num2str(i) ' = [Ai(' num2str(i) ',:) cell(1,1)];'];
    end
end
end

function code = allocateOutputs(net)
code = {['Y = cell(' num2str(net.numOutputs) ',TS);']};
end

function code = simulateInput(net,i,useTransposedData)
import nnet.codegen.*;
import nnet.nn.*;
code = {};
code{end+1} = ['% Input ',num2str(i)];
if(useTransposedData)
    code{end+1} = ['X{' num2str(i) ',ts} = X{' num2str(i) ',ts}'';'];
end
numFcns = numel(net.inputs{i}.processFcns);
if numFcns == 0
    if isInputDelayed(net,i)
        code{end+1} = ['Xd' num2str(i) '{xdts} = X{' num2str(i) ',ts};'];
    else
        code{end+1} = '% no processing';
    end
else
    xvar = ['X{' num2str(i) ',ts}'];
    if isInputDelayed(net,i)
        xdvar = ['Xd' num2str(i) '{xdts}'];
    else
        xdvar = ['Xp' num2str(i)];
    end
    inputvar = xvar;
    resultvar = 'temp';
    if (numFcns == 0)
        code{end+1} = [xdvar ' = ' xvar ';'];
    else
        for j=1:numFcns
            if (j==numFcns)
                resultvar = xdvar;
            end
            module = net.inputs{i}.processFcns{j};
            if ~isempty(getStructFieldsFromMFile(module,'apply','settings'))
                settings = inputSettingName(i,j);
            else
                settings = '[]';
            end
            code{end+1} = [resultvar ' = ' module '_apply(' inputvar ',' settings ');'];
            inputvar = resultvar;
        end
    end
end
end

function code = simulateLayer(net,i)
import nnet.codegen.*;
import nnet.nn.*;
code = {};
code{end+1} = ['% Layer ',num2str(i)];
zcount = 0;
terms = {};
tapdelays = 0;
isNetprod = strcmp(net.layers{i}.netInputFcn,'netprod');
% Bias
if net.biasConnect(i)
    terms{end+1} = ['repmat(b' num2str(i) ',1,Q)'];
end
% Input Weights
for j=1:net.numInputs
    if net.inputConnect(i,j)
        module = net.inputWeights{i,j}.weightFcn;
        if isInputDelayed(net,j)
            delays = net.inputWeights{i,j}.delays;
            delays = ['mod(xdts-' mat2str(delays) '-1,' num2str(net.numInputDelays+1) ')+1'];
            tapdelays = tapdelays+1;
            code{end+1} = ['tapdelay' num2str(tapdelays) ' = cat(1,Xd' num2str(j) '{' delays '});'];
            input = ['tapdelay' num2str(tapdelays)];
        elseif isempty(net.inputs{j}.processFcns)
            input = ['X{' num2str(j) ',ts}'];
        else
            input = ['Xp' num2str(j)];
        end
        weight = ['IW' num2str(i) '_' num2str(j)];
        if strcmp(module,'dotprod')
            terms{end+1} = [weight,'*' input];
            if isNetprod, terms{end} = ['(' terms{end} ')']; end
        else
            zcount = zcount + 1;
            code{end+1} = ['z',num2str(zcount),' = ',module,'_apply(',weight,',',input,');'];
            terms{end+1} = ['z',num2str(zcount)];
        end
    end
end
% Layer Weights
for j=1:net.numLayers
    if net.layerConnect(i,j)
        module = net.layerWeights{i,j}.weightFcn;
        if (net.numLayerDelays > 0)
            delays = net.layerWeights{i,j}.delays;
            delays = ['mod(adts-' mat2str(delays) '-1,' num2str(net.numLayerDelays+1) ')+1'];
            tapdelays = tapdelays+1;
            code{end+1} = ['tapdelay' num2str(tapdelays) ' = cat(1,Ad' num2str(j) '{' delays '});'];
            input = ['tapdelay' num2str(tapdelays)];
        else
            input = ['a' num2str(j)];
        end
        weight = ['LW' num2str(i) '_' num2str(j)];
        if strcmp(module,'dotprod')
            terms{end+1} = [weight,'*',input];
            if isNetprod, terms{end} = ['(' terms{end} ')']; end
        else
            zcount = zcount + 1;
            code{end+1} = ['z',num2str(zcount),' = ',module,'_apply(',weight,',',input,');'];
            terms{end+1} = ['z',num2str(zcount)];
        end
    end
end
% Net Input Function
module = net.layers{i}.netInputFcn;
S = num2str(net.layers{i}.size);
if strcmp(module,'netsum')
    if isempty(terms)
        nExpression = ['zeros(' S ',Q)'];
    else
        nExpression = operatorList(terms,' + ');
    end
elseif strcmp(module,'netprod')
    if isempty(terms)
        nExpression = ['ones(' S ',Q)'];
    else
        nExpression = operatorList(terms,' .* ');
    end
else
    nExpression = [module,'({',commaList(terms),'},' S ',Q)'];
end
% Transfer Function
if (net.numLayerDelays > 0)
    advar = ['Ad' num2str(i) '{adts}'];
else
    advar = ['a' num2str(i)];
end
module = net.layers{i}.transferFcn;
if strcmp(module,'purelin')
    code{end+1} = [advar ' = ' nExpression ';'];
else
    code{end+1} = [advar ' = ' module '_apply(' nExpression ');'];
end
end

function code = simulateOutput(net,i,useTransposedData)
import nnet.codegen.*;
code = {};
output2layer = find(net.outputConnect);
ii = output2layer(i);
if (net.numLayerDelays > 0)
    avar = ['Ad' num2str(ii) '{adts}'];
else
    avar = ['a' num2str(ii)];
end
inputvar = avar;
resultvar = 'temp';
yvar = ['Y{' num2str(i) ',ts}'];
code{end+1} = ['% Output ',num2str(i)];
numFcns = numel(net.outputs{ii}.processFcns);
if (numFcns == 0)
    code{end+1} = [yvar ' = ' avar ';'];
else
    for j=numFcns:-1:1
        if (j==1)
            resultvar = yvar;
        end
        module = net.outputs{ii}.processFcns{j};
        if ~isempty(getStructFieldsFromMFile(module,'reverse','settings'))
            settings = outputSettingName(i,j);
        else
            settings = '[]';
        end
        code{end+1} = [resultvar ' = ' module '_reverse(' inputvar ',' settings ');'];
        inputvar = resultvar;
    end
end
if(useTransposedData)
    code{end+1} = ['Y{' num2str(i) ',ts} = Y{' num2str(i) ',ts}'';'];
end
end

function code = finalInputStates(net)
if (net.numInputDelays > 0)
    code = {'Xf = [Xi(:,xits) X(:,xts)];'};
else
    code = {['Xf = cell(' num2str(net.numInputs) ',0);']};
end
end

function code = finalLayerStates(net)
code = {['Af = cell(' num2str(net.numLayers) ',' num2str(net.numLayerDelays) ');']};
if (net.numLayerDelays > 0)
    for i=1:net.numLayers
        code{end+1} = ['Af(' num2str(i) ',:) = Ad' num2str(i) '(:,ats);'];
    end
end
end


