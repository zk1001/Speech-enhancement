function code = genFunctionMatrixDynamic(net,name,filepath)

% Copyright 2012-2015 The MathWorks, Inc.

import nnet.codegen.*;
code = [...
    functionInterface(net,name) ...
    functionSummary(name) ...
    {'%'} ...
    commentText(functionHelp(net,filepath,name)) ...
    {''} ...
    {'% ===== NEURAL NETWORK CONSTANTS ====='} ...
    {''} ...
    constantBlock(net) ...
    {''} ...
    {'% ===== SIMULATION ========'} ...
    {''} ...
    simulationBlock(net) ...
    {'end'} ...
    {''} ...
    {'% ===== MODULE FUNCTIONS ========'} ...
    {''} ...
    allModuleFunctions(net) ...
    ];
end

function code = functionInterface(net,name)
code = {['function ' functionCall(net,name)]};
end

function code = functionSummary(name)
code = {['%' upper(name) ' neural network simulation function.']};
end

function code = functionCall(net,name)
import nnet.codegen.*;
import nnet.nn.*;
inputs = numberedStrings('x',net.numInputs);
outputs = numberedStrings('y',net.numOutputs);
for i=1:net.numInputs
    if isInputDelayed(net,i)
        inputs{end+1} = ['xi' num2str(i)];
        outputs{end+1} = ['xf' num2str(i)];
    end
end
for i=1:net.numLayers
    if isLayerDelayed(net,i)
        inputs{end+1} = ['ai' num2str(i)];
        outputs{end+1} = ['af' num2str(i)];
    end
end
inputs = commaList(inputs);
outputs = commaList(outputs);
code = ['[' outputs '] = ' name '(' inputs ')'];
end

function code = functionHelp(net,filepath,name)
import nnet.codegen.*;
code = combineTextBlocks({...
    sourceSummary ...
    syntaxHelp(net,name)  ...
    });
end

function code = sourceSummary
code = {['Generated by Neural Network Toolbox function genFunction, ' datestr(datevec(now)) '.']};
end

function code = syntaxHelp(net,name)
import nnet.codegen.*;
code = {};
output2layer = find(net.outputConnect);
inputs = numberedStrings('x',net.numInputs);
outputs = numberedStrings('y',net.numOutputs);
code{end+1} = [functionCall(net,name) ' takes these arguments:'];
for i=1:net.numInputs
    code{end+1} = ['  ',inputs{i},' = ',num2str(net.inputs{i}.size),'xTS matrix, input #' num2str(i)];
end
if net.numInputDelays > 0
    for i=1:net.numInputs
        code{end+1} = ['  xi',num2str(i),' = ',num2str(net.inputs{i}.size),'x' num2str(net.numInputDelays) ' matrix, initial ' num2str(net.numInputDelays) ' delay states for input #' num2str(i) '.'];
    end
end
if net.numLayerDelays > 0
    for i=1:net.numLayers
        code{end+1} = ['  ai',num2str(i),' = ',num2str(net.layers{i}.size),'x' num2str(net.numLayerDelays) ' matrix, initial ' num2str(net.numLayerDelays) ' delay states for layer #' num2str(i) '.'];
    end
end
code{end+1} = 'and returns:';
for i=1:net.numOutputs
    ii = output2layer(i);
    code{end+1} = ['  ',outputs{i},' = ',num2str(net.outputs{ii}.size),'xTS matrix, output #' num2str(i)];
end
if net.numInputDelays > 0
    NID = num2str(net.numInputDelays);
    for i=1:net.numInputs
        code{end+1} = ['  xf',num2str(i),' = ',num2str(net.inputs{i}.size),'x' num2str(net.numInputDelays) ' matrix, final ' num2str(net.numInputDelays) ' delay states for input #' num2str(i) '.'];
    end
end
if net.numLayerDelays > 0
    for i=1:net.numLayers
        code{end+1} = ['  af',num2str(i),' = ',num2str(net.layers{i}.size),'x' num2str(net.numLayerDelays) ' matrix, final ' num2str(net.numLayerDelays) ' delay states for layer #' num2str(i) '.'];
    end
end
code{end+1} = 'where TS is the number of timesteps.';
end

function code = simulationBlock(net)
import nnet.codegen.*;
import nnet.nn.*;
inputStateBlocks = {};
for i=1:net.numInputs
    if isInputDelayed(net,i)
        inputStateBlocks{end+1} = simulateInputState(net,i);
    end
end
if (net.numInputDelays + net.numLayerDelays) > 0
    tsdCode = {'  % Rotating delay state position'};
    if (net.numInputDelays > 0)
        tsdCode{end+1} = ['  xdts = mod(ts+' num2str(net.numInputDelays-1) ',' num2str(net.numInputDelays+1) ')+1;'];
    end
    if (net.numLayerDelays > 0)
        tsdCode{end+1} = ['  adts = mod(ts+' num2str(net.numLayerDelays-1) ',' num2str(net.numLayerDelays+1) ')+1;'];
    end
    if ~isempty(tsdCode), tsdCode{end+1} = ''; end
    finaltsCode = {'% Final delay states'};
    if (net.numInputDelays > 0)
        finaltsCode = [finaltsCode {
            ['finalxts = TS+(1: ' num2str(net.numInputDelays) ');'] ...
            ['xits = finalxts(finalxts<=' num2str(net.numInputDelays) ');'] ...
            ['xts = finalxts(finalxts>' num2str(net.numInputDelays) ')-' num2str(net.numInputDelays) ';'] ...
            }];
    end
    if (net.numLayerDelays > 0)
        finaltsCode = [finaltsCode {
            ['finalats = TS+(1:' num2str(net.numLayerDelays) ');'] ...
            ['ats = mod(finalats-1,' num2str(net.numLayerDelays+1) ')+1;'] ...
            }];
    end
else
    tsdCode = {};
    finaltsCode = {};
end
if (net.numInputs > 0)
    TSexp = 'size(x1,2)';
else
    TSexp = '1';
end
code = [ ...
    {'% Dimensions'} ...
    {['TS = ' TSexp '; % timesteps']} ...
    {''} ...
    combineTextBlocks([
    inputStateBlocks ...
    {encloseText('% Layer Delay States',allocateLayerStates(net))} ...
    {encloseText('% Allocate Outputs',allocateOutputs(net))} ...
    ]) ...
    {''} ...
    {'% Time loop'} ...
    {'for ts=1:TS'} ...
    {''} ...
    indentText([ ...
    tsdCode ...
    timeBlock(net)...
    ]) ...
    {'end'} ...
    {''} ...
    finaltsCode ...
    finalInputStates(net) ...
    finalLayerStates(net) ...
    ];
end

function code = timeBlock(net)
import nnet.codegen.*;
inputBlocks = cell(1,net.numInputs);
for i=1:net.numInputs
    inputBlocks{i} = simulateInput(net,i);
end
layerBlocks = cell(1,net.numLayers);
layerOrder = nn.layer_order(net);
for i=1:net.numLayers
    layerBlocks{i} = simulateLayer(net,layerOrder(i));
end
outputBlocks = cell(1,net.numOutputs);
for i=1:net.numOutputs
    outputBlocks{i} = simulateOutput(net,i);
end
code = combineTextBlocks([inputBlocks layerBlocks outputBlocks]);
end

function code = simulateInputState(net,i)
import nnet.codegen.*;
code = {};
R = num2str(net.inputs{i}.processedSize);
code{end+1} = ['% Input ',num2str(i) ' Delay States'];
numFcns = numel(net.inputs{i}.processFcns);
lastVar = ['xi' num2str(i)];
processedVar = ['xd' num2str(i)];
for j=1:numFcns
    module = net.inputs{i}.processFcns{j};
    if ~isempty(getStructFieldsFromMFile(module,'apply','settings'))
        settings = inputSettingName(i,j);
    else
        settings = '[]';
    end
    code{end+1} = [processedVar ' = ' module '_apply(' lastVar ',' settings ');'];
    lastVar = processedVar;
end
code{end+1} = [processedVar ' = [' lastVar ' zeros(' R ',1)];'];
end

function code = allocateLayerStates(net)
import nnet.nn.*;
code = {};
for i=1:net.numLayers
    if isLayerDelayed(net,i)
        code{end+1} = ['ad' num2str(i) ' = [ai' num2str(i) ' zeros(' num2str(net.layers{i}.size) ',1)];'];
    end
end
end

function code = allocateOutputs(net)
code = cell(1,net.numOutputs);
output2layer = find(net.outputConnect);
for i=1:net.numOutputs
    ii = output2layer(i);
    code{i} = ['y' num2str(i) ' = zeros(' num2str(net.outputs{ii}.size) ',TS);'];
end
end

function code = simulateInput(net,i)
import nnet.codegen.*;
import nnet.nn.*;
code = {};
code{end+1} = ['% Input ',num2str(i)];
numFcns = numel(net.inputs{i}.processFcns);
if numFcns == 0
    if isInputDelayed(net,i)
        code{end+1} = ['xd' num2str(i) '(:,xdts) = x' num2str(i) '(:,ts);'];
    else
        code{end+1} = '% no processing';
    end
else
    xvar = ['x' num2str(i) '(:,ts)'];
    if isInputDelayed(net,i)
        xdvar = ['xd' num2str(i) '(:,xdts)'];
    else
        xdvar = ['xp' num2str(i)];
    end
    inputvar = xvar;
    resultvar = 'temp';
    if (numFcns == 0)
        code{end+1} = [xdvar ' = ' xvar ';'];
    else
        for j=1:numFcns
            if (j==numFcns)
                resultvar = xdvar;
            end
            module = net.inputs{i}.processFcns{j};
            if ~isempty(getStructFieldsFromMFile(module,'apply','settings'))
                settings = inputSettingName(i,j);
            else
                settings = '[]';
            end
            code{end+1} = [resultvar ' = ' module '_apply(' inputvar ',' settings ');'];
            inputvar = resultvar;
        end
    end
end
end

function code = simulateLayer(net,i)
import nnet.codegen.*;
import nnet.nn.*;
code = {};
code{end+1} = ['% Layer ',num2str(i)];
zcount = 0;
tapdelays = 0;
terms = {};
isNetprod = strcmp(net.layers{i}.netInputFcn,'netprod');
% Bias
if net.biasConnect(i)
    terms{end+1} = ['b' num2str(i)];
end
% Input Weights
for j=1:net.numInputs
    if net.inputConnect(i,j)
        module = net.inputWeights{i,j}.weightFcn;
        if isInputDelayed(net,j)
            delays = net.inputWeights{i,j}.delays;
            Rd = net.inputs{j}.processedSize * numel(delays);
            delays = ['mod(xdts-' mat2str(delays) '-1,' num2str(net.numInputDelays+1) ')+1'];
            tapdelays = tapdelays + 1;
            code{end+1} = ['tapdelay' num2str(tapdelays) ' = reshape(xd' num2str(j) '(:,' delays '),' num2str(Rd) ',1);'];
            input = ['tapdelay' num2str(tapdelays)];
        elseif ~isempty(net.inputs{j}.processFcns)
            input = ['xp' num2str(j)];
        else
            input = ['x' num2str(j) '(:,ts)'];
        end
        weight = ['IW' num2str(i) '_' num2str(j)];
        if strcmp(module,'dotprod')
            terms{end+1} = [weight,'*' input];
            if isNetprod, terms{end} = ['(' terms{end} ')']; end
        else
            zcount = zcount + 1;
            code{end+1} = ['z',num2str(zcount),' = ',module,'_apply(',weight,',',input,');'];
            terms{end+1} = ['z',num2str(zcount)];
        end
    end
end
% Layer Weights
for j=1:net.numLayers
    if net.layerConnect(i,j)
        module = net.layerWeights{i,j}.weightFcn;
        if isLayerDelayed(net,j)
            delays = net.layerWeights{i,j}.delays;
            Rd = net.layers{j}.size * numel(delays);
            delays = ['mod(adts-' mat2str(delays) '-1,' num2str(net.numLayerDelays+1) ')+1'];
            tapdelays = tapdelays + 1;
            code{end+1} = ['tapdelay' num2str(tapdelays) ' = reshape(ad' num2str(j) '(:,' delays '),' num2str(Rd) ',1);'];
            input = ['tapdelay' num2str(tapdelays)];
        else
            input = ['a' num2str(j)];
        end
        weight = ['LW' num2str(i) '_' num2str(j)];
        if strcmp(module,'dotprod')
            terms{end+1} = [weight,'*',input];
            if isNetprod, terms{end} = ['(' terms{end} ')']; end
        else
            zcount = zcount + 1;
            code{end+1} = ['z',num2str(zcount),' = ',module,'_apply(',weight,',',input,');'];
            terms{end+1} = ['z',num2str(zcount)];
        end
    end
end
% Net Input Function
module = net.layers{i}.netInputFcn;
S = num2str(net.layers{i}.size);
if strcmp(module,'netsum')
    if isempty(terms)
        nExpression = ['zeros(' S ',1)'];
    else
        nExpression = operatorList(terms,' + ');
    end
elseif strcmp(module,'netprod')
    if isempty(terms)
        nExpression = ['ones(' S ',1)'];
    else
        nExpression = operatorList(terms,' .* ');
    end
else
    nExpression = [module,'({',commaList(terms),'},S,1)'];
end
% Transfer Function
if isLayerDelayed(net,i)
    advar = ['ad' num2str(i) '(:,adts)'];
else
    advar = ['a' num2str(i)];
end
module = net.layers{i}.transferFcn;
if strcmp(module,'purelin')
    code{end+1} = [advar ' = ' nExpression ';'];
else
    code{end+1} = [advar ' = ' module '_apply(' nExpression ');'];
end
end

function code = simulateOutput(net,i)
import nnet.codegen.*;
import nnet.nn.*;
code = {};
output2layer = find(net.outputConnect);
ii = output2layer(i);
if isLayerDelayed(net,ii)
    avar = ['ad' num2str(ii) '(:,adts)'];
else
    avar = ['a' num2str(ii)];
end
inputvar = avar;
resultvar = 'temp';
yvar = ['y' num2str(i) '(:,ts)'];
code{end+1} = ['% Output ',num2str(i)];
numFcns = numel(net.outputs{ii}.processFcns);
if (numFcns == 0)
    code{end+1} = [yvar ' = ' avar ';'];
else
    for j=numFcns:-1:1
        if (j==1)
            resultvar = yvar;
        end
        module = net.outputs{ii}.processFcns{j};
        if ~isempty(getStructFieldsFromMFile(module,'reverse','settings'))
            settings = outputSettingName(i,j);
        else
            settings = '[]';
        end
        code{end+1} = [resultvar ' = ' module '_reverse(' inputvar ',' settings ');'];
        inputvar = resultvar;
    end
end
end

function code = finalInputStates(net)
import nnet.nn.*;
code = {};
for i=1:net.numInputs
    if isInputDelayed(net,i)
        code{end+1} = ['xf' num2str(i) ' = [xi' num2str(i) '(:,xits) x' num2str(i) '(:,xts)];'];
    end
end
end

function code = finalLayerStates(net)
code = {};
for i=1:net.numLayers
    if isLayerDelayed(net,i)
        code{end+1} = ['af' num2str(i) ' = ad' num2str(i) '(:,ats);'];
    end
end
end

function flag = isLayerDelayed(net,i)
for j=1:net.numLayers
    if net.layerConnect(j,i)
        if any(net.layerWeights{j,i}.delays > 0)
            flag = true;
            return
        end
    end
end
flag = false;
end
